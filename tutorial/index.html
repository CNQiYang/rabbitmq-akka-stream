<body>
    <div>
        <h2>Overview</h2>
        <p>
        This project aims to show how reactive Akka Streams could provide an appealing way of working with RabbitMQ.
        </p>
        <p>
        We are assuming some basic knowledge of RabbitMQ. Otherwise you wouldn't probably be here. 
        But if this is one of these rare cases then please look closer at this cool piece of technology here <a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a> . 
        </p>
        <p>
        You should have a RabbitMQ server installed locally with a management plug-in.
        </p>
        <p>
        This application simulates a simplified censorship (yes, censorship) procedure, that intercepts private messages, makes a content analysis, and qualifies the message as OK or NOT OK.
        So the scenario is as follows:
        </p>
        <pre><code>Queue --> Akka Stream --> Exchange</code></pre>
        <ol>
          <li>Consume message from a RabbitMQ queue
          <li>Process it through Akka Stream
          <li>Publish it back to one of the two destination RabbitMQ exchanges (based on some simple decision making process).
        </ol>
    </div>
    <div>
        <h2>Explore</h2>
        <p>
        After running the application, go to the RabbitMQ management console at <a href="http://localhost:15672/">http://localhost:15672/</a> , 
        find an exchange named <strong>censorship.inbound.exchange</strong> and start publishing messages.
        </p>
        <p>
        You should observe two effects:
        </p>
        <ul>
        <li>Text of your message will be logged to a console,
        <li>Modified version of your message will land in either <strong>censorship.ok.queue</strong> or <strong>censorship.nok.queue</strong> (based on the text content of your message).
        </ul>
        <p>
        You will notice that messages containing the word <em>'terror'</em> will go to the <strong>nok</strong> queue. This is the initial censorship filter. Feel free to modify the "forbidden words" list.
        </p>
    </div>
    <div>
        <h2>Consuming, processing, publishing</h2>
        <p>
        Below you will find main steps for this whole process.
        </p>
        <h3>Consuming messages</h3>
        <p>
        <code>RabbitConsumerActor</code> is responsible for initializing a channel to the queue and registering 
        a consumer for that queue. It will then serve as a stream <code>Producer</code>, by calling <code>onNext</code> whenever a new message comes from the server and the stream is ready to process it. Otherwise the message will be rejected and requeued on RabbitMQ.
        </p>
        <h3>Processing messages</h3>
        <p>
        To split the work into logical parts we are using <code>Duct[In, Out]</code>. This allows us to define some message processing independently from the <code>Flow</code> and connect the two later.
        </p>
        <h3>Publishing back to RabbitMQ</h3>
        <p>
        <code>RabbitPublisher</code> is responsible for initializing an outgoing channel. 
        It also creates a <code>Duct</code> containing the logic for publishing a message back to a RabbitMQ exchange.
        </p>
        <h3>Putting it all together</h3>
        <p>
        After receiving a connection from <code>RabbitConnectionActor</code> we combine these functions and call <code>consume()</code> on the final flow. Simplified code would look something like this:
        </p>
        <pre><code>(Flow(rabbitConsumer) append domainProcessingDuct append publisherDuct).consume(materializer)</code></pre>
    </div>
    <div>
        <h2>This is it</h2>
        <p>
        You just saw a clean functional way of working with RabbitMQ. There are of course many issues that haven't been addressed here, like the RabbitMQ Quality of Service property or rejecting messages at later stages of processing (to name a few). Also this is just a simple wrapper over the official RabbitMQ client, not a complete solution. But this should get you going and hopefully this is the way we'll be doing things in the future.
        </p>
    </div>
</body>